# Консенсус в Exonum

Как правило, [алгоритм консенсуса][wiki:consensus] - это процесс получения
согласованного результата группой участников. В Exonum алгоритм консенсуса
используется для согласования списка транзакций в блоках, добавленных в блокчейн.
Другая цель алгоритма состоит в том, чтобы гарантировать, что результаты
выполнения транзакций интерпретируются одинаково всеми узлами в сети блокчейн.

Алгоритм консенсуса в Exonum использует некоторые идеи из алгоритма,
[предложенного в Tendermint][tendermint_consensus], но имеет
[несколько отличительных особенностей](#отличительные-особенности) по сравнению
с ним и другими алгоритмами консенсуса для блокчейнов.

## Предположения

Алгоритм консенсуса Exonum предполагает, что участники консенсуса могут быть
идентифицированы. Таким образом, алгоритм подходит для приватных блокчейнов,
на которые и ориентирован Exonum, а не для публичных блокчейнов.

Не все узлы в сети блокчейн могут активно участвовать в алгоритме консенсуса.
Для активных участников консенсуса есть особая роль *валидаторы* или *узлы-валидаторы*.
Например, в [блокчейн-консорциуме][public_and_private_blockchains]
валидаторы могут контролироваться компаниями, участвующими в консорциуме.

Алгоритм консенсуса должен работать при наличии сбоев, т.е. когда участники сети
могут вести себя аномально. Алгоритм консенсуса Exonum предполагает худшее; он
работает в предположении, что любой отдельный узел, или даже группа узлов в сети
блокчейн, могут дать сбой или быть скомпрометированы находчивым противником
(скажем, хакером или коррумпированным администратором). Эта модель угрозы известна
в информатике как [задача византийских генералов][wiki:bft].
Соответственно, алгоритм консенсуса Exonum является алгоритмом византийского
консенсуса.

С точки зрения компьютерных наук, алгоритм консенсуса Exonum принимает обычные
предположения:

- Узлы валидаторы считаются [частично синхронными][partial_synchrony],
  то есть их вычислительные характеристики не сильно отличаются
- Сеть также частично синхронна. То есть все сообщения доставляются за конечное
  количество времени, которое, однако, неизвестно заранее
- Каждый валидатор имеет доступ к локальному **секундомеру** для определения
  временных интервалов. С другой стороны, в системе нет глобального
  синхронизированного времени
- Валидаторы могут быть идентифицированы с помощью криптосистемы с открытым ключом,
  соответственно, связь между валидаторами аутентифицирована

Те же предположения используются в [PBFT][pbft] (наиболее известном алгоритме
византийского консенсуса) и его преемниках.

## Обзор Алгоритма

Процесс достижения консенсуса относительно следующего блока (на высоте блокчейна
`H`) состоит из нескольких **раундов**, пронумерованных от 1\. Первый раунд
начинается, как только валидатор принимает блок на высоте `H - 1`. Начало раунда
определяется фиксированным расписанием: раунды начинаются через регулярные
промежутки времени. Поскольку глобального времени нет, раунды могут начинаться
в разное время для разных валидаторов.

Когда наступает раунд номер `R`, предыдущие раунды не завершаются.
То есть, раунд `R` означает, что валидатор может обрабатывать сообщения,
относящиеся к раунду, с номером, не большим чем `R`.
Текущее состояние валидатора может быть описано как кортеж `(H, R)`.
`R` может отличаться среди валидаторов, но высота `H` обычно одна и та же.
Если определенный валидатор отстает (например, во время его начальной
синхронизации или если он был отключен на некоторое время), его высота может
быть ниже. В этом случае валидатор может запросить отсутствующие блоки у других
валидаторов и полных узлов, чтобы быстро синхронизироваться с остальными узлами
сети.

### Упрощенное Описание

Если объяснять *очень* просто, раунды выполняются следующим образом:

1. В каждом раунде есть *узел-лидер*. Лидер раунда выдвигает *предложение (proposal)* для
   следующего блока и транслирует его в сети. Логика выбора узла-лидера описана
   в отдельном алгоритме.
2. Валидаторы могут голосовать за это предложение, транслируя сообщение типа *prevote*.
   Это сообщение означает, что валидатор смог обработать предложение и все
   транзакции, указанные в нем.
3. После того, как валидатор собрал достаточное количество голосов от
   абсолютного большинства других валидаторов, он применяет транзакции,
   указанные в предложении, и транслирует сообщение типа *precommit*. Это
   сообщение содержит результат выполнения предложения в виде
   [хеша нового состояния блокчейна](storage.md).
   Сообщение типа *precommit* означает что отправитель готов принять
   соответствующий предложенный блок в блокчейне, но, чтобы быть уверенным в этом
   решении, ему нужно узнать что другие валидаторы думают по этому поводу.
4. Наконец, если валидатор собрал сообщения типа *precommit* от квалифицированного
   большинства с одним и тем же хешем состояния для одного и того же предложения,
   предлагаемый блок принимается в блокчейн.

### Детальное Описание

!!! note "Примечание"
    Далее в описании +2/3 означает более двух третей валидаторов, а -1/3
    означает менее одной трети.

Алгоритм описанный выше очень упрощен:

- Валидатор может получать сообщения в любом порядке из-за сетевых задержек.
  Например, валидатор может получить сообщение типа *precommit* или *prevote*
  для предложения блока, которое не известно валидатору
- Могут быть валидаторы, действующие вне алгоритма консенсуса.
  Валидаторы могут быть отключены от сети, или повреждены противником. Чтобы
  формализовать это предположение, предполагается, что -1/3 валидаторов в любой
  момент времени могут действовать произвольно. Такие валидаторы в информатике
  называются *византийскими*; все другие валидаторы называются *честными*

Описанный выше трехэтапный консенсус (proposal, prevote и precommit)
создан для того, чтобы алгоритм консенсуса работал в этих условиях.
Точнее, алгоритм должен сохранять *безопасность* и *жизнеспособность*:

- Безопасность означает, что, как только один честный валидатор принял блок,
  ни один другой честный валидатор никогда не примет какой-либо другой блок
  на этой же высоте
- Жизнеспособность означает, что честные валидаторы продолжают время от времени
  принимать блоки

#### Блокировка

Византийские валидаторы могут отправлять разные сообщения различным валидаторам.
Для обеспечения безопасности в этих условиях, в алгоритме консенсуса Exonum
используется понятие *блокировок*.

Валидатор, который собрал +2/3 сообщений типа prevote за предложение блока,
блокируется на этом предложении. Заблокированный валидатор не голосует за какое-либо
другое предложение, кроме того, на котором он заблокировался. Когда начинается новый
раунд, заблокированный валидатор немедленно отправляет сообщение типа prevote,
указывающее, что он заблокировался на определенном предложении. Другие валидаторы
могут запрашивать сообщения типа prevote, которые привели к блокировке валидатора,
если они не имеют их локально (эти сообщения известны как
*доказательство блокировки*).

!!! note "Пример"
    Валидатор A получает сообщения типа prevote от валидаторов B и C,
    но они не получают этих сообщений друг от друга из-за проблем со связью.
    Несмотря на это, валидаторы B и C могут запросить сообщений друг друга у валидатора A.

Блокировки могут меняться: если A заблокировался на предложении и в следующем раунде все
остальные валидаторы заблокировались на следующем предложении, A в конечном итоге
обновит свою блокировку.

### Запросы

Поскольку сообщения могут быть потеряны или перепутаны местами, консенсус Exonum
использует механизм *запросов* для получения неизвестной информации от других
полных узлов. Узел может отправить другим узлам запрос на необходимую, но пока
неизвестную, информацию.

!!! note "Пример"
    Запрос отправляется, если узел получает консенсусное сообщение с высоты,
    большей чем его локальная высота. Предполагается, что другой узел ответит
    сообщением, которое содержит транзакции в принятом блоке, а также
    доказательство того, что блок действительно принят (т.е. сообщения типа
    precommit от +2/3 валидаторов).

Есть запросы на все консенсусные сообщения: proposal, prevote и precommit.
Поскольку консенсусные сообщения аутентифицируются с помощью цифровых подписей,
они могут быть отправлены непосредственно в ответ на запросы.

### Обзор Состояний Узлов

Порядок состояний в предлагаемом алгоритме выглядит следующим образом:

```none
Принятие -> (Раунд)+ -> Принятие -> ...
```

На временной шкале эти состояния выглядят следующим образом (для одного из
валидаторов):

```none
Принятие: |  H  |                       | H+1 |                        ...
Раунд1:   |     | R1                    |     | R1                     ...
Раунд2:   |          | R2               |          | R2                ...
Раунд3:   |               | R3          |               | R3           ...
Раунд4:   |                    | R4     |                    | R4      ...
...
------------------------------------------------------------------>  Время
```

Обратите внимание, что раунды имеют определенное время начала, но у них нет
определенного конечного времени (они заканчиваются когда получен следующий блок).

Это отличается от обычного поведения частично синхронных алгоритмов консенсуса,
в которых раунды имеют определенное время окончания (т.е., сообщения,
сгенерированы во время раунда `R`, должны обрабатываться только во время
раунда `R`).

## Коммуникация в Сети

### Сообщения

В алгоритме консенсуса используются несколько типов сообщений. Все
сообщения аутентифицируются с помощью цифровых подписей с открытым
ключом, так что отправитель сообщения однозначно известен и не может
быть поддельным. Кроме того, использование цифровых подписей (вместо,
например, [HMACs][wiki:hmac]) гарантирует, что сообщения могут быть
свободно повторно переданы по сети. Более того, это можно сделать с
помощью балансировщиков нагрузки, которые не имеют представления о
содержании сообщений.

#### Propose

Сообщения `Propose` - это набор транзакций, предложенный лидером раунда для
включения в следующий блок. Вместо целых транзакций, сообщения `Propose`
содержат только хеши транзакций. Валидатор, получивший сообщение `Propose`, может
запросить отсутствующие транзакции у других узлов.

Если все валидаторы ведут себя корректно, `Propose` отправляется только
узлом-лидером раунда.

#### Prevote

Сообщение `Prevote`- это голосование за сообщение `Propose`. `Prevote`
указывает, что валидатор имеет правильно сформированное сообщение
`Propose` и все транзакции, указанные в нем. `Prevote` транслируется всем
валидаторам.

#### Precommit

Сообщение `Precommit` выражает готовность принять определенное предложение в
качестве следующего блока в блокчейне. `Precommit` транслируется всем валидаторам.

#### Status

Сообщение `Status` - это информационное сообщение о текущей высоте. Оно
отправляется с периодичностью, записанной в параметре `status_timeout`
[глобальной конфигурации](configuration.md).

#### BlockResponse

Сообщение `BlockResponse` содержит блок и набор сообщений `Precommit`, которые
позволили принять этот блок. Сообщения `BlockResponse` отправляются по запросу.

### Запросы Сообщений

Существуют сообщения с запросами на транзакции, сообщения `Propose` и `Prevote`,
а также блоки. Правила генерации и обработки этих сообщений довольно просты.

!!! note "Пример"
    Сообщение `ProposeRequest` генерируется, если валидатор получает консенсусное
    сообщение (`Prevote` или `Precommit`), относящееся к сообщению
    `Propose`, которое неизвестно валидатору. Узел, который получил сообщение
    `ProposeRequest`, в ответ отправляет запрошенное сообщение `Propose`.

## Отличительные Особенности

По сравнению с другими алгоритмами византийского консенсуса, алгоритм консенсуса
Exonum имеет следующие отличительные особенности:

### Неограниченные Раунды

Раунды имеют фиксированное время начала, но у них нет определенного времени
окончания (раунд заканчивается только после принятия следующего блока).
Это помогает уменьшить задержки при нестабильном сетевом соединении между
валидаторами.

Предположим, что консенсусные сообщения из определенного раунда должны быть
обработаны в рамках этого же раунда. Если состояние сети ухудшится, валидаторам,
возможно, не удастся принять предложение до конца раунда. Тогда в следующем
раунде весь процесс предложения блока и голосования за него должен начаться
снова. Продолжительность следующего раунда должна быть увеличена, чтобы при
плохом сетевом подключением, блок мог быть принят во время нового раунда.
Необходимость повторения работы, которая уже была выполнена, и
увеличения длительности раунда приведут к дополнительным задержкам в принятии
нового блока.

В отличие от случая, рассмотренного в предыдущем абзаце, отсутствие
фиксированного времени окончания раунда в Exonum позволяет системе принять
предложение блока с минимальной задержкой.

### Разделение Роботы

Сообщения `Propose` включают только хеши транзакций. (Транзакции включены
непосредственно в сообщения `BlockResponse`.) Кроме того, выполнение транзакций
задерживается; транзакции применяются только в момент замыкания узла на
сообщении `Propose`.

Отложенная обработка транзакций снижает негативное влияние вредоносных узлов
на пропускную способность и задержки в системы. Такой подход разделяет обработку
транзакций между этапами алгоритма:

- На этапе `Prevote` валидаторы только проверяют, что список транзакций,
  включенных в предложение, является правильным (валидатор проверяет, что все
  транзакции в `Propose` ранее уже были сохранены этим узлом. Правильность
  транзакции проверяется при ее получении, узлы не хранят неправильные
  транзакции)
- На этапе `Precommit` валидаторы применяют транзакции к текущему состоянию блокчейна
- На этапе принятия нового блока, валидаторы проверяют, что они достигли одного
  и того же состояния после применения транзакций из предложения

Если византийский валидатор отправляет разным валидаторам предложения с разным
порядком транзакций, валидаторам не нужно тратить время на проверку порядка и
применение транзакций на этапе `Prevote`.
Разный порядок транзакций будет обнаружен при попытке сопоставления
`propose_hash` полученного в сообщениях `Prevote` от других валидаторов и
`propose_hash` полученного в сообщении `Propose`.

Таким образом, разделение работы помогает снизить негативное влияние
византийских узлов на общую производительность системы.

### Алгоритм Запросов

Алгоритм запросов позволяет валидатору восстановить любую консенсусную
информацию с помощью других валидаторов. Это оказывает положительное влияние
на жизнеспособность системы.

[partial_ordering]: https://ru.wikipedia.org/wiki/Частично_упорядоченное_множество#Определение_и_примеры
[partial_synchrony]: http://groups.csail.mit.edu/tds/papers/Lynch/podc84-DLS.pdf
[public_and_private_blockchains]: https://blog.ethereum.org/2015/08/07/on-public-and-private-blockchains/
[tendermint_consensus]: https://github.com/tendermint/tendermint/wiki/Byzantine-Consensus-Algorithm
[wiki:consensus]: https://en.wikipedia.org/wiki/Consensus_(computer_science)
[wiki:bft]: https://ru.wikipedia.org/wiki/Задача_византийских_генералов
[pbft]: http://pmg.csail.mit.edu/papers/osdi99.pdf
[wiki:hmac]: https://ru.wikipedia.org/wiki/HMAC
[src-messages]: https://github.com/exonum/exonum/blob/master/exonum/src/messages/protocol.rs
