# Обзор архитектуры

<!-- cspell:ignore postgre -->

Данная страница описывает основные архитектурные решения инфраструктуры Exonum:
[обработку транзакций](#обработка-транзакций),
[структуру сети](#структура-сети),
[алгоритм консенсуса](#консенсус),
[организацию хранения данных](#хранение-данных),
[сервисы](#модульность-и-сервисы),
и [криптографию, используемую в Exonum](#криптография).

## Обработка транзакций

Для внешнего приложения, блокчейн на Exonum представляет собой хранилище типа
ключ-значение и [транзакционную систему][wiki:oltp], управляющую
этим хранилищем. Его основные функции &mdash; обработка транзакций, сохранение данных
и ответы на запросы на чтение от внешних клиентов.

**Транзакция** &mdash; это основной объект, с которым работает Exonum. Транзакция
представляет собой атомарный патч, который применяется к хранилищу. Транзакции
аутентифицируются с помощью цифровых подписей с
открытым ключом. Транзакции должны быть проверены и упорядочены до того, как
они будут считаться принятыми / записанными. Упорядочивание выполняется по
[алгоритму консенсуса](#консенсус). Алгоритм также гарантирует, что будут
совершены только успешно проверенные транзакции.

Транзакции строятся по шаблонам (их может быть несколько). Каждый шаблон транзакции
имеет набор переменных,
которые влияют на выполнение транзакции и используются для сериализации
транзакций для передачи по сети и сохранения. (Следовательно, транзакции можно
сравнить с хранимыми процедурами в реляционных СУБД). Шаблоны транзакций и
правила обработки для каждого шаблона определяются
[сервисами](#модульность-и-сервисы). В частности, сервисы определяют правила
проверки транзакций и способ применения транзакций к хранилищу.

Все данные в блокчейне Exonum разделены на две части:

- **хранилище данных**, которое содержит данные, структурированные в таблицы;
- **журнал транзакций**, т.е. полная история всех транзакций, когда-либо
применявшихся к хранилищу данных.

Поскольку транзакции включают операции с хранилищем, такие
как создание нового значения или обновление уже сохраненных значений,
актуальное состояние хранилища данных может быть полностью восстановлено из
журнала транзакций. Когда в сети Exonum появляется новый узел, он скачивает
уже сгенерированные блоки и применяет транзакции из этих блоков к хранилищу
данных одну за другой. Такой подход позволяет видеть всю историю любого
фрагмента данных и упрощает аудит.

Используя журнал транзакций, Exonum реализует
[репликацию][wiki:state-machine-repl] для достижения отказоустойчивости.
Это гарантирует согласование состояний хранилища данных между узлами сети.
Такой же подход часто используют вне блокчейна, например, в базах данных MongoDB
и PostgreSQL.

### Блоки

Exonum собирает транзакции в **блоки**; весь блок одобряется атомарно. Если
транзакция еще не была записана в какой-либо блок, она не считается принятой.
После утверждения блока каждая транзакция в нем выполняется последовательно,
и изменения применяются к хранилищу данных.

Блоки Exonum состоят из следующих частей:

- хеш предыдущего блока Exonum;
- список одобренных транзакций. Когда узлы выполняют блок, они выполняют каждую
транзакцию в указанном порядке и применяют изменения к данным в хранилище.
Разные типы транзакций выполняются различными сервисами;
- хеш нового состояния хранилища данных. Само состояние хранилища в блок не
включено, однако транзакции применяются детерминированно и с единственным возможным
результатом. Хеш хранилища
гарантированно совпадает для всех валидаторов, потому что его согласование
встроено в алгоритм консенсуса Exonum.

Поскольку каждый блок включает хеш предыдущего блока, невозможно изменить один
блок без соответствующих изменений в каждом из следующих блоков. Это
гарантирует неизменяемость журнала транзакций: после совершения транзакции, она
не может быть изменена или удалена из журнала задним числом. Точно так же
невозможно вставить транзакцию в середину журнала.

!!! note "Примечание"
    Согласование хеша хранилища данных не только означает, что полные узлы
    выполняют транзакции в одном и том же порядке; они также должны выполнять
    все транзакции одинаково. Это предотвращает сценарий, в котором результаты
    выполнения отличаются среди узлов в сети (например, из-за
    недетерминированных инструкций в коде выполнения транзакции), что может
    привести к возникновению различных проблем.

## Структура сети

Сеть Exonum состоит из *полных узлов*, подключенных через одноранговые
соединения, и *легких клиентов*.

### Полные узлы

**Полные узлы** копируют все содержимое блокчейна и соответствуют репликам в
распределенных базах данных. Все полные узлы аутентифицируются с помощью
криптосистемы с открытым ключом. Полные узлы подразделяются на 2 категории:

- **Аудиторы** копируют всю информацию блокчейна. Они могут генерировать новые
  транзакции, но не могут выбирать, какие транзакции должны быть включены в
  блоки (т.е. не могут генерировать новые блоки).
- **Валидаторы** обеспечивают жизнеспособность сети. Только валидаторы могут
  генерировать новые блоки, используя
  [алгоритм византийского консенсуса](#консенсус).
  Валидаторы получают транзакции, проверяют их и включают в новый блок. Список
  валидаторов ограничен администраторами сети и обычно должен состоять из 4-15
  узлов.

### Легкие клиенты

**Легкие клиенты** представляют клиентов в парадигме клиент-сервер. Они
подключаются к полным узлам для извлечения нужной им информации из блокчейна
и для отправки транзакций. Exonum предоставляет механизм «доказательств»,
основанный на криптографических обязательствах через деревья Меркла. Этот
механизм позволяет проверить, что ответ от полного узла был действительно
одобрен большинством валидаторов.

## Консенсус

Exonum использует собственную модификацию византийского консенсуса (похожего
на PBFT), чтобы гарантировать, что в любой момент существует только одна
согласованная версия блокчейна. Предполагается, что система децентрализована,
т.е. любой узел может выйти из строя или быть скомпрометирован. Консенсус
*аутентифицирован*, участники консенсуса (т.е. валидаторы) идентифицируются
с помощью криптосистемы с открытым ключом.

Чтобы создать новый блок и проголосовать за него используется трехшаговый
алгоритм.

- Алгоритм консенсуса делится на раунды, начало которых определяется каждым
  валидатором на основе его собственного источника времени. Для каждого раунда существует
  предопределенный валидатор-лидер, который определяется на основе числа раундов и
  высоты цепочки. Лидер создает
  *предложение блока (proposal)* и отправляет его другим валидаторам.
- Другие валидаторы проверяют это предложение, и если оно правильное, голосуют
  за него, передавая сообщения типа *prevote* другим валидаторам.
- Если валидатор собирает сообщения типа *prevote* для одного и того же
  предложения от абсолютного большенства валидаторов, он выполняет
  транзакции в предложении, создает сообщение типа *precommit* с новым
  состоянием хранилища данных и отправляет его валидаторам.
- Наконец, если валидатор получает сообщения типа *precommit* от
  абсолютного большинства валидаторов для одного и того же предложения,
  предложение становится новым блоком и фиксируется в локальном хранилище
  валидатора.

!!! note "Примечание"
    Блок может быть записан в блокчейн в разное время для разных валидаторов.
    Алгоритм консенсуса гарантирует, что валидаторы не могут записать несколько
    блоков на одной и той же высоте цепочки блокчейна (см.
    [свойство безопасности](#безопасность-и-жизнеспособность)
    ниже).

Если валидатор не получает правильное предложение блока в текущем раунде,
он в конечном итоге переходит к следующему раунду по истечении времени
ожидания и готов рассматривать предложения от лидера в новом раунде.

Алгоритм консенсуса поддерживает ситуации, когда до 1/3 валидаторов
действуют злонамеренно, отключены или изолированы от сети. Это теоретический
предел алгоритма, учитывая условия, в которых работает Exonum (частичная
асинхронность между узлами из-за отсутствия времени в системе). Например,
лидер может несвоевременно сгенерировать предложение или отправить различные
предложения разным валидаторам. В конечном счете, все
честно действующие валидаторы одобрят один и тот же новый блок.

Валидаторы могут быть изменены во время роботы блокчейна путем
[обновления](#сервис-обновления-конфигурации)
глобальной конфигурации блокчейна. Этот механизм можно использовать для замены
ключей валидаторов, а также для добавления, замены или удаления узлов-валидаторов
без необходимости перезапуска блокчейна.

### Безопасность и жизнеспособность

Технически алгоритм консенсуса, используемый в Exonum, гарантирует
2 основных свойства:

- **Безопасность** означает, что, как только один корректный
  валидатор зафиксирует блок, все остальные правильно действующие валидаторы в
  конечном итоге зафиксируют этот же блок на той же высоте; другими словами,
  блокчейн не может разделиться.
- **Жизнеспособность** означает, что правильно действующие валидаторы
  продолжают время от времени записывать блоки.

Эти свойства формально доказаны для алгоритма консенсуса, действующего в
частично синхронной сети, в условиях, при которых до 1/3 узлов валидаторов
скомпрометированы или отключены. Если сеть является асинхронной (т.е.
между валидаторами существует произвольно высокая задержка соединения),
алгоритм гарантирует безопасность, но может потерять жизнеспособность.
То же самое происходит в большинстве сценариев, в которых скомпрометировано
более 1/3 (но менее 2/3) валидаторов.

## Хранение данных

### RocksDB

[RocksDB][rocks-db] используется для локального хранения данных, с которыми
работают транзакции. Эта база данных обеспечивает высокую эффективность
и минимальные затраты памяти.

### Типы таблиц

Exonum поддерживает несколько типов таблиц данных, представляющих собой
типизированные коллекции (списки, множества и таблицы):

- `ListIndex` реализует список.
- `MapIndex` представляет собой ассоциативный массив / хранилище типа ключ-значение.
- [`ProofListIndex`](../../architecture/storage.md#prooflistindex)
  представляет собой расширенную версию списка. Он реализует
  сбалансированное (но не обязательно полное) двоичное дерево Меркла. Листья
  дерева сохраняют непосредственно элементы массива, в то время как промежуточные
  вершины сохраняют хеши от объединенных данных дочерних вершин. `ProofListIndex`
  позволяет только добавлять данные или обновлять уже сохраненные элементы.
- [`ProofMapIndex`](../../architecture/storage.md#proofmapindex)
  расширяет таблицу. Он основан на Merkle Patricia деревьях, реализованных
  как двоичные деревья. Листья дерева сохраняют непосредственные значения из карты.
  Промежуточные узлы состоят из следующих четырех частей:

    - хеш левого дочернего значения;
    - хеш правого дочернего значения;
    - ключ для левого дочернего узла;
    - ключ для правого дочернего узла.

- `ValueSetIndex` и `KeySetIndex` реализуют множества, и оба сводят их к
ассоциативным массивам (как это обычно делается в языках программирования). `ValueSetIndex`
использует хеши элементов множества как ключи, а сами элементы &mdash; как значения,
в то время как `KeySetIndex`
использует сами элементы в качестве ключей, а вместо значений хранит `null`.
Таким образом, `KeySetIndex`
предпочтительнее, когда заданные элементы имеют относительно короткую
сериализацию и требуется сохранять их порядок.
`ValueSetIndex` лучше подходит для сложных элементов или элементов, которые
можно искать с помощью хеша.

И `ListIndex`, и `ProofListIndex` поддерживают обновление по индексу и позволяют
только добавление данных. `MapIndex` и `ProofMapIndex` позволяют вносить,
обновлять или удалять пары ключ-значение. `KeySetIndex` и `ValueSetIndex` позволяют
добавлять и удалять элементы из множества. Наконец, все перечисленные коллекции поддерживают
итерирование по элементам (или ключам, значениям и парам ключ-значение в случае карт).

### Доказательства

`ProofListIndex` и `ProofMapIndex` позволяют эффективно создавать
доказательства того, что определенные значения сохраняются под определенными
ключами. Чтобы доказать это, достаточно вернуть список хешей из корня дерева к
определенной ячейке (путь Меркла). Таблицы Merkle Patricia также позволяют
создавать доказательства того, что в базе данных нет данных с определенным
ключом.

Когда полный узел связывается с легким клиентом, запрошенные данные могут быть
возвращены с доказательствами их наличия или отсутствия. Это позволяет эффективно
доказывать достоверность данных.

## Модульность и сервисы

Помимо ядра, Exonum включает в себя возможность создания **сервисов**. В то
время как ядро ​​отвечает за консенсус и играет роль промежуточного программного
обеспечения для отправки и получения транзакций и блоков, сервисы реализуют
всю бизнес-логику блокчейна и являются основной точкой расширения функционала
Exonum.

Сервисы Exonum взаимодействуют с внешним миром с помощью *конечных точек REST API*.
Сервис может определять 3 типа конечных точек:

- **Транзакции** соответствуют методам `POST / PUT` для REST-сервисов. Они
  преобразуют состояние блокчейна. Все транзакции в блокчейне полностью
  упорядочены, как описано выше, и результат их выполнения согласован между
  полными узлами в сети блокчейн.
- **Запросы на чтение** соответствуют методам GET для REST-сервисов. Они извлекают
  информацию из блокчейна по возможности вместе с доказательствами. Запросы на
  чтение выполняются локально, не являются глобально упорядоченными и не могут
  изменять состояние блокчейна.
- **Приватные конечные точки** предоставляют административный интерфейс
  локальному экземпляру сервиса. Они могут использоваться для настройки
  локальной конфигурации сервиса, например, для управления приватными ключами,
  специфичными для сервисов. Приватные конечные точки выполняются локально, не
  являются глобально упорядоченными и не могут напрямую изменять состояние
  блокчейна (хотя они могут генерировать транзакции и добавлять их в сеть)

!!! note "Примечание"
    Еще один тип конечных точек, *событие*,
    [будет доступен в скором времени](../../roadmap.md).
    События будут реализовывать [шаблон проектирования издатель-подписчик][wiki:pubsub],
    позволяя легким клиентам и сервисам подписываться на события, которые
    выпускаются сервисами.

Внешние приложения могут связываться с сервисными конечными точками через
HTTP REST API, используя JSON в качестве формата сериализации. Exonum облегчает
задания по промежуточной обработке задач для сервисов, таких как
прослушивание HTTP-запросов, отправка входящих транзакций и запросов на чтение
в соответствующий сервис, выполнение преобразования в JSON и обратно, и т. д.

Поскольку сервисы являются модулями Rust, их можно легко использовать повторно
в проектах Exonum. Вы можете использовать сервисы с открытым исходным кодом,
уже написанные сообществом, или создать свой собственный сервис и выложить его в
открытый доступ.

### Смарт-контракты

Конечные точки, определяемые сервисами, выполняют ту же роль, что и
смарт-контракты в других блокчейн платформах. Они определяют бизнес-логику
блокчейна, позволяют извлекать данные из блокчейна и могут быть повторно
использованы в разных проектах. Частичные аналоги для этой модели выполнения &mdash;
это конечные точки REST-сервисов и хранимые процедуры для систем управления
базами данных.

Следующие ключевые моменты отличают смарт-контракты Exonum от других моделей,
используемых в блокчейнах:

- **Ограниченная среда.** Exonum выполняет только предопределенные типы
  запросов, не позволяя выполнять ненадежный код полученный от клиента. Это
  приводит к более контролируемой среде и упрощает обеспечение безопасности
  смарт-контрактов.
- **Отсутствие изоляции.** Обработка запросов выполняется в том же контексте
  выполнения, что и ядро ​​системы. Это выигрышно сказывается на
  производительности, хотя и имеет определенные риски по отношению к
  безопасности.
- **Локальное состояние.** Сервисы Exonum могут определять локальное состояние,
  которое относится к узлу, на котором работает сервис. Локальное состояние может
  использоваться для управления секретной информацией (например, приватными
  ключами). Локальное состояние может быть изменено через приватные конечные точки сервиса.
  Используя локальное состояние, сервисы могут быть более активными,
  чем их аналоги в других блокчейнах. Например,
  [сервис анкоринга](#сервис-анкоринга)
  использует локальное состояние для полной автоматизации подписания анкорящих
  транзакций.
- **Разделение обработки транзакций.** Проверка транзакций &mdash; это отдельный шаг
  обработки транзакций. Он выполняется сразу после получения транзакции, прежде
  чем применять транзакцию к состоянию блокчейна. Проверка может включать
  проверку подлинности (например, проверку подписи транзакции), а также другие
  структурные проверки содержимого транзакции. В то же время проверка транзакции
  не имеет доступа к текущему состоянию блокчейна.

!!! note "Примечание"
    Изоляция выполнения сервисов является высокоприоритетной задачей
    в [планах развития Exonum](../../roadmap.md).

### Существующие сервисы

#### Сервис обновления конфигурации

Хотя каждый узел имеет свой собственный файл конфигурации, некоторые настройки
должны быть изменены для всех узлов одновременно. Данный сервис позволяет
обновлять конфигурацию с помощью самого блокчейна.

Используя сервис обновления конфигурации, любой валидатор может предлагать
новую конфигурацию, и другие валидаторы могут голосовать за нее. Для
применения предлагаемых изменений требуется одобрение от абсолютного
большинства валидаторов. Однако, принятие предложения не делает новую конфигурацию
активной. Новая конфигурация включает параметр
`actual_from` указывающий на высоту, при достижении которой активируется новая
конфигурация.

#### Сервис анкоринга

Сервис анкоринга записывает хеш текущего состояния блокчейна Exonum в блокчейн
Биткоин через определенный интервал времени. Данные для анкоринга
аутентифицируются квалифицированным большинством валидаторов с помощью
инструментов цифровой подписи доступных в Биткоине.

Анкоринг повышает безопасность системы: даже если злоумышленник получит контроль
над каждым валидатором или все валидаторы вступят в сговор, невозможно незаметно
изменить журнал транзакций. После любого изменения,
модифицированные задним числом хеши блоков будут отличаться от тех, которые
записаны в Биткоин блокчейне. Чтобы задним числом изменить данные в блокчейне
Exonum, злоумышленнику также необходимо будет скомпрометировать Биткоин
блокчейн. Стоимость такой атаки будет измеряться в миллиардах долларов США.

Кроме того, заанкоренные данные вместе с доказательствами поддаются проверке,
даже если блокчейн Exonum по какой-то причине станет недоступен. Это
свойство может быть использовано для получения бессрочных электронных чеков.

## Криптография

### Хеширование

Exonum использует [SHA-256][wiki:sha256] для всех операций хеширования, включая
создание транзакций и идентификаторов блоков, построения деревьев Меркла и
хранения бинарных данных в хеш-таблицах.

### Криптосистема с открытым ключом и управление ключами

Как транзакции, так и сообщения относящиеся к консенсусу аутентифицируются с
помощью [цифровых подписей Ed25519][wiki:ed25519] реализованных с
использованием [sodiumoxide][sodiumoxide] (оболочка [libsodium][libsodium] для
Rust). В большинстве случаев транзакции создаются внешними объектами (такими
как легкие клиенты). Предполагается, что они управляют
соответствующими ключами подписи. Ключами также могут управлять сами полные
узлы. В этом случае приватный ключ хранится в локальной конфигурации узла,
не входит в блокчейн и уникален для конкретного узла. Оптимальная практика
заключается в том, чтобы управлять такими ключами локально через приватные
API соответствующего сервиса.

Ядро Exonum определяет две пары ключей Ed25519 для полных узлов:

- **Ключ консенсуса** используется для подписания сообщений относящихся к
  консенсусу (для валидаторов) и подписания сетевых сообщений (для валидаторов
  и аудиторов).
- **Административный ключ** имеется только у валидаторов и используется для
  административных задач (таких, как голосование за обновления конфигурации).

Сервисы могут использовать дополнительные пары ключей, в том числе из других
криптосистем. Например, сервис анкоринга определяет дополнительную пару ключей
secp256k1 для подписания анкорящих транзакций в Биткоине.

!!! warning "Важно"
    В настоящее время локальная конфигурация узла (которая включает в себя все
    его приватные ключи, используемые как в консенсусе, так и в сервисах)
    хранится в виде обычного текста. Этот недочет будет исправлен в ближайшее время.

[arch-guide]: https://github.com/exonum/exonum/blob/master/ARCHITECTURE.md
[wiki:oltp]: https://en.wikipedia.org/wiki/Online_transaction_processing
[wiki:state-machine-repl]: https://en.wikipedia.org/wiki/State_machine_replication
[rocks-db]: http://rocksdb.org/
[wiki:sha256]: https://en.wikipedia.org/wiki/SHA-2
[wiki:ed25519]: https://en.wikipedia.org/wiki/EdDSA
[libsodium]: https://download.libsodium.org/doc/
[sodiumoxide]: https://dnaq.github.io/sodiumoxide/sodiumoxide/
[wiki:pubsub]: https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern
