# Оракул времени

<!-- cspell:ignore tlsdate,roughtime -->

[**Exonum-time**][exonum-time] – это сервис оракула времени для Exonum.
Этот сервис позволяет определить время, импортировать его из внешнего мира в
блокчейн и сохранять его текущее значение в блокчейне.

## Задача

Для реализации бизнес-логики многих практических блокчейн решений требуется
доступ
к календарному времени. Время можно получить, выполнив определенные действия в
блокчейне. Эти действия должны соответствовать следующим критериям:

- **Использование валидаторов**. Поскольку Exonum используется для создания
  приватных блокчейнов, естественно предположить, что входные данные для
  бизнес-логики определения времени должны предоставляться валидаторами. Это
  предположение может быть обобщено и будет касаться также абстрактных
  полунадежных идентифицируемых объектов, но для упрощения понимания эта статья будет сосредоточена конкретно на случае, когда время определяется
  узлами-валидаторами.
- **Надежность**. Значение времени должно быть устойчивым к зловредному
  поведению узлов-валидаторов.
- **Согласованность**. Время должно быть одинаковым на всех узлах, чтобы
  гарантировать, что транзакции выполняются детерминированным образом. Это
  означает, что время должно быть записано в хранилище блокчейна Exonum. Таким
  образом, «текущее» время будет меняться одинаково на всех узлах во время
  выполнения транзакций, в том числе и во время обновления узлов.
- **Достаточная точность**. Указанное время должно быть достаточно точным.
  На практике приемлемое отклонение от реального времени составляет несколько секунд.
- **Монотонность**. Значение времени должно только увеличиваться. Это
  прагматичное требование упрощает использование времени при реализации
  бизнес-логики.

## Предположения

Локальное время на всех узлах-валидаторах считается надежным. Чтобы получить
локальное надежное время, валидаторы могут применять внешние решения, такие
как [tlsdate][tlsdate], [roughtime][roughtime], и т.д.

Если локальное время на узле-валидаторе некорректно, такой узел считается
византийским. Точно так же, как и алгоритм консенсуса, алгоритм, используемый
оракулом времени, продолжает корректно работать, если до трети валидаторов
являются византийскими.

## Описание идеи

Каждый валидатор в определенное время отправляет транзакцию с указанием своего
локального времени (обычно сразу после принятия каждого блока). Сервис времени
сохраняет индекс с самыми новыми значениями времени, указанными отдельно каждым
валидатором. Данный индекс обновляется после
каждой транзакции от любого из валидаторов.  Как мы продемонстрируем
[далее](#доказательство-корректности), это время можно считать надежным,
учитывая указанные выше предположения.

## Описание

### Схема

Схема данных сервиса **exonum-time** состоит из двух индексов:

- **time**  
  Утвержденное время, выводимое сервисом, которое может использоваться другой
  бизнес-логикой блокчейна.
- **validators_time**  
  Индекс на основе дерева Меркла с последними известными локальными метками
  времени всех узлов-валидаторов. Значения в этом индексе используются для обновления
  индекса  `time` и могут быть полезны для мониторинга, диагностики и т.п.

### Транзакции

Сервис реализует единственный тип транзакции, позволяя валидатору выводить свое
текущее время, подтвержденное цифровой подписью этого валидатора.

Логика выполнения транзакции выглядит следующим образом:

1. Убедиться, что автор транзакции является одним из валидаторов. Если нет,
   прекратить обработку транзакции.
2. Убедиться, что время, указанное в транзакции, больше, чем время сохраненное
   для этого валидатора в хранилище. Если нет, прекратить обработку транзакции.
3. Обновить время для этого валидатора в индексе `validators_time`.
4. Если количество меток в индексе, принадлежащих текущим валидаторам,
   составляет не менее `2f + 1`, где `f = (n - 1) / 3` – это максимальное
   количество византийских валидаторов, выполнить следующие шаги. В противном
   случае прекратить обработку транзакции.
5. Отсортировать метки времени текущих валидаторов в порядке убывания (начиная
   с самого нового времени).
6. Найти время с индексом `f + 1` в полученном списке.
7. Если полученное время `t` больше, чем предыдущее утвержденное время,
   присвоить утвержденному времени значение `t`.

Таким образом, утвержденное время может быть обновлено после каждой транзакции
с фактическим временем от любого узла-валидатора. Процедура учитывает возможные
изменения в списке валидаторов, обеспечивает монотонность индекса `time` и
допускает зловредное поведение узлов-валидаторов.

## Доказательство корректности

Допустим что `T` обозначает список текущих временных меток валидаторов,
отсортированных в порядке убывания, как указано в шаге 5 вышеприведенного
алгоритма. В системе с количеством византийских узлов не большим чем `f`,
любое время из `T` с индексом в интервале `[f + 1, 2f + 1]` является:

- Временем честного узла или
- Временем между отметками времени двух честных узлов. Поэтому такое время можно
  считать надежным.

Из практических соображений, всегда выбирается временная метка с индексом
`f + 1`,
так как это значение является надежным и в то же время самым новым.

[exonum-time]: https://github.com/exonum/exonum/tree/master/services/time
[tlsdate]: https://github.com/ioerror/tlsdate
[roughtime]: https://roughtime.googlesource.com/roughtime
