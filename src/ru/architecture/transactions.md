# Transactions

**Транзакция** в Exonum,
[как и в обычных базах данных](https://en.wikipedia.org/wiki/Database_transaction),
представляет собой группу последовательных операций с данными (то есть
с [хранилищем ключ-значение](../../architecture/storage.md) в
Exonum). Правила обработки транзакций определены в [сервисах](services.md);
эти правила определяют бизнес-логику любого блокчейна на Exonum.

Транзакции выполняются
[атомарно, последовательно, изолированно и с неизменяемым результатом][wiki:acid].
Если выполнение транзакции нарушает определенные инварианты данных,
транзакция полностью откатывается, так что она не влияет на постоянное
хранилище.

Если транзакция верна, ее можно включить в блок посредством
[алгоритма консенсуса](consensus.md), осуществляемого валидаторами. Консенсус
предусматривает [полное упорядочение][wiki:order] всех транзакций; из любых
двух транзакций в блокчейне всегда можно определить, какая из них будет первой.
Транзакции последовательно применяются к хранилищу Exonum
в том же порядке, в котором они помещаются в блокчейн.

Все транзакции аутентифицируются с помощью цифровых подписей с открытым ключом.
Как правило, транзакция содержит ключ проверки подписи (также известный как
открытый ключ) среди ее параметров. Таким образом, авторизация (проверка того,
имеет ли автор транзакции на самом деле право выполнить транзакцию) может быть
выполнена с помощью создания [инфраструктуры открытого ключа][wiki:pki] и/или
различных ограничений, основанных на этом ключе.

!!! tip "Совет"
    Для минимизации рисков безопасности рекомендуется децентрализовать процесс
    подписания транзакции. Грубо говоря, не должно быть едного сервера,
    подписывающего все транзакции в системе; это может стать узким местом в
    безопасности системы. Одним из вариантов децентрализации подписи является
    использование [библиотеки легкого клиента](https://github.com/exonum/exonum-client).

!!! note "Пример"
    В примере [сервиса криптовалюты][cryptocurrency],
    владелец криптовалюты может разрешить передачу своих монет путем подписания
    транзакции передачи средств ключом, связанным с монетами. Аутентификация
    в этом случае означает проверку того, что транзакция имеет цифровую
    подпись, сделанную конкретным ключом, а авторизация означает, что этот
    ключ связан с достаточным количеством монет для совершения транзакции.

## Шаблоны транзакций

Все транзакции в Exonum *стандартизированы*. Каждая транзакция Exonum
определяется ее шаблоном и набором параметров, а не явной
последовательностью операций над хранилищем. Последовательность операций
может быть однозначно восстановлена при наличии идентификатора шаблона и его
параметров.
Такой подход обеспечивает более безопасную и контролируемую среду для обработки
транзакций.

Шаблоны транзакций определяются в сервисах и могут рассматриваться как
аналоги хранимых процедур в системах управления базами данных или конечных
точек POST/PUT в веб-сервисах. Подобно этим случаям, целью создания шаблонов
является ограниченить возможные шаблоны транзакций (например, для сохранения
определенных инвариантов) и отделить детали реализации от вызова транзакции.

## Жизненный цикл

### 1. Создание

Транзакция создается внешней сущностью (например,
[легким клиентом](clients.md)) и подписывается с помощью закрытого ключа,
необходимого для авторизации транзакции.

### 2. Попадание в сеть

После создания транзакция отправляется в блокчейн сеть.
Для этого обычно легкий клиент подключается к полному узлу
через [соответствующую конечную точку транзакции](services.md#транзакции).

!!! note "Примечание"
    Поскольку транзакции используют универсальную проверенную криптографию
    (цифровые подписи)
    для аутентификации, транзакция теоретически может быть отправлена в сеть
    кем угодно, кто знает о ней. При этом транзакция может быть отправлена в
    сеть через произвольное время после ее создания.

!!! tip "Совет"

    С точки зрения легкого клиента выполнение транзакции происходит асинхронно;
    полные узлы не возвращают статус выполнения синхронно в ответ на запрос
    клиента. Чтобы определить статус транзакции, вы можете запросить ее статус,
    используя [запросы на чтение](services.md#запросы-на-чтение), определенные
    в соответствующих сервисах или в проводнике блокчейна. Если транзакция
    действительна (т.е. ее проверка `verify` возвращает статус `true`),
    ожидается, что она будет добавлена в блок за считанные секунды.

### 3. Проверка

После того полный узел получает транзакцию, он осуществляет ее поиск среди
выполненных транзакций, используя хеш транзакции как уникальный
идентификатор. Если транзакция была выполнена ранее, она
отбрасывается, и следующие шаги не выполняются.

Обращение к способу выполнения транзакции
происходит при помощи идентификатора типа `(service_id, message_id)`.
Метод `verify` выполняется для проверки внутренней структуры транзакции.
Если проверка выполнена успешно, транзакция добавляется в пул
неподтвержденных транзакций; в противном случае она отбрасывается, а следующие
шаги не выполняются.

### 4. Распространение по сети

Если транзакция, которая включена в пул неподтвержденных транзакций,
получена узлом не от другого полного узла,
транзакция передается всем полным узлам, к которым подключен данный узел.
В частности, узел передает транзакции, полученные от легких клиентов,
или сгенерированые сервисами, но не ретранслирует
транзакции, передаваемые одноранговыми узлами, или полученные
из [запросов](../../advanced/consensus/requests.md) во время
выполнения консенсуса.

### 5. Консенсус

После того, как транзакция достигнет пула валидатора, она может быть включена
в предложение блока (или несколько предложений).

!!! summary "Заметка"
    В настоящее время порядок включения транзакций в предложение
    определяется хешем транзакции. Честные валидаторы создают предложения,
    включая в них транзакции по возрастанию хеша Такое поведение не является
    единственно верным и, скорее всего, изменится в будущем.

Метод `execute` транзакции выполняется во время этапа блокировки алгоритма
консенсуса. Это происходит, когда валидатор собрал все транзакции для
предложения блока и при этом соблюдены определенные условия, которые
позволяют предположить, что указанное предложение будет принято в ближайшем
будущем.
Результаты выполнения отражены в сообщениях косенсуса типа `Precommit` и
согласовываются в рамках алгоритма консенсуса. Таким образом,
транзакции гарантировано выполняются одинаково на всех узлах.

### 6. Добавление в блокчейн

Когда определенное предложение блока и результат его исполнения набирают
достаточное количество голосов среди валидаторов, блок с нужной транзакцией
добавляется в блокчейн. Все транзакции из добавленного блока последовательно
применяются к состоянию блокчейна путем вызова метода `execute`; при этом
транзакции отображаются в блоке в том же порядке.
Следовательно, порядок выполнения одинаковый для каждого узла в сети.

## Свойства транзакций

### Чистота

Метод `verify` в транзакциях является
[чистым](https://en.wikipedia.org/wiki/Pure_function), что означает, что
результат проверки не зависит от состояния блокчейна и локальной среды
валидатора. Таким образом, проверка транзакций может быть легко
распараллелена. Кроме того, достаточно проверить любую транзакцию только один
раз &mdash; когда она отправляется в пул неподтвержденных транзакций.

!!! note "Примечание"
    Как недостаток, `verify` не может выполнять проверки, зависящие от
    состояния блокчейна. Например, в сервисе криптовалюты, транзакция перевода
    средств
    не может проверить, имеет ли отправитель достаточное количество монет для
    перевода.

### Последовательная согласованность

[Последовательная согласованность](https://en.wikipedia.org/wiki/Sequential_consistency)
в целом означает, что блокчейн выглядит как централизованная система для
внешнего наблюдателя (например, для легкого клиента). Все транзакции в блокчейне
влияют на состояние блокчейна, как если бы они выполнялись одна за другой в
порядке, указанном в блоках. Последовательная согласованность обеспечивается
[алгоритмом консенсуса](consensus.md).

### Неповторимость транзакций

Неповторимость транзакции означает, что злоумышленник не может извлечь старую
выполлненную
транзакцию из блокчейна и снова применить ее к состоянию цепочки.

!!! note "Пример"
    Предположим, Алиса платит Бобу 10 монет, используя
    [образец сервиса криптовалюты][cryptocurrency].
    Неповторимость транзакции не позволяет Бобу извлечь транзакцию Алисы и
    поместить ее в сеть повторно, чтобы заработать дополнительные монеты.

Неповторимость транзакции также является мерой предосторожности против
DoS-атак; он не позволяет злоумышленнику спамить в сеть его собственными
или чужими транзакциями.

Неповторимость транзакции в Exonum гарантируется отбрасыванием транзакций, уже
включенных в блокчейн (путем определения хеша транзакции), на этапе проверки
транзакции.

!!! tip "Совет"
    Если транзакция не является [идемпотентной][wiki:idempotent], она должна
    иметь дополнительное поле для того, чтобы ее можно было отличить от других
    транзакций с тем же набором параметров. Это поле должно иметь достаточную
    длину (например, 8 байт) и может генерироваться как строго
    детерминированно (например, через счетчик), так и (псевдо-)случайно.
    См. `TxTransfer.seed` в сервисе криптовалюты в качестве примера.

[wiki:acid]: https://en.wikipedia.org/wiki/ACID
[wiki:order]: https://en.wikipedia.org/wiki/Total_order
[wiki:pki]: https://en.wikipedia.org/wiki/Public_key_infrastructure
[wiki:idempotent]: https://en.wikipedia.org/wiki/Idempotence
[cryptocurrency]: https://github.com/exonum/exonum/blob/master/examples/cryptocurrency
[core-tx]: https://github.com/exonum/exonum/blob/master/exonum/src/blockchain/service.rs
[rust-trait]: https://doc.rust-lang.org/book/first-edition/traits.html
[mdn:safe-int]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger
[wiki:currying]: https://en.wikipedia.org/wiki/Currying
[rust-result]: https://doc.rust-lang.org/book/first-edition/error-handling.html
