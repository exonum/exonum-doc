# Оракул времени

<!-- cspell:ignore tlsdate,roughtime -->

[**exonum-time**][exonum-time] – это оракул времени для Exonum.
Этот сервис позволяет определить время, импортировать его из внешнего мира в
блокчейн и сохранять его текущее значение в блокчейне.

## Задача

Для реализации бизнес-логики многих практичных блокчейн решений требуется доступ
к календарному времени. Время можно получить, выполнив определенные действия в
блокчейне. Эти действия должны соответствовать следующим критериям:

- **Использование валидаторов**. Поскольку Exonum используется для создания
  приватных блокчейнов, естественно предположить, что входные данные для
  бизнес-логики определения времени должны предоставляться валидаторами. Это
  предположение может быть обобщено, чтобы включать абстрактные полунадежные
  идентифицируемые объекты, но для упрощения понимания эта статья будет
  сосредоточена конкретно на случае, когда время определяется узлами-валидаторами.
- **Надежность**. Значение времени должно быть стойким к вредоносному поведению
  узлов-валидаторов.
- **Соглашение**. Время должно быть одинаковым на всех узлах, чтобы
  гарантировать, что транзакции выполняются детерминированным образом. Это
  означает, что время должно быть записано в хранилище блокчейна Exonum. Таким
  образом, «текущее» время будет меняться одинаково на всех узлах во время
  выполнения транзакций, в том числе и во время обновления узлов.
- **Определенная точность**. Указанное время должно быть достаточно точным.
  На практике приемлемое отклонение составляет несколько секунд.
- **Однообразие**. Значение времени должно только увеличиваться. Это
  прагматическое требование упрощает использование времени при реализации
  бизнес-логики.

## Предположения

Локальное время на всех узлах-валидаторах считается надежным. Чтобы получить
локальное надежное время, валидаторы могут применять внешние решения, такие
как [tlsdate][tlsdate], [roughtime][roughtime], и т.д.

Если местное время на узле-валидаторе некорректно, такой узел считается
византийским. Точно так же, как и алгоритм консенсуса, алгоритм, используемый
оракулом времени, продолжает корректно работать если до трети валидаторов
являются византийскими.

## Общий замысел

Каждый валидатор в определенное время отправляет транзакцию с указанием своего
местного времени (обычно сразу после принятия каждого блока). Сервис времени
сохраняет индекс с самыми новыми значениями времени, указанными отдельно каждым
валидатором. 1/3 часть этих значений (упорядоченных по мере убывания времени)
хранится отдельно, эта часть считается фактическим временем и обновляется после
каждой транзакции от любого из валидаторов.  Как мы продемонстрируем
[далее](#доказательство-корректности), это время можно считать надежным,
учитывая указанные выше предположения.

## Описание

### Схема

Схема данных сервиса **exonum-time** состоит из двух индексов:

- **time**  
  Утвержденное время, выводимое сервисом, которое может использоваться другой
  бизнес-логикой блокчейна.
- **validators_time**  
  Индекс с последними известными локальными метками времени всех
  узлов-валидаторов. Значения в этом индексе используются для обновления
  индекса  `time` и могут быть полезны для мониторинга, диагностики и т. п.

### Транзакции

Сервис реализует единственный тип транзакции, позволяя валидатору выводить свое
текущее время, подтвержденное цифровой подписью этого валидатора.

Логика выполнения транзакции выглядит следующим образом:

1. Убедиться, что автор транзакции является одним из валидаторов. Если нет,
   прекратить обработку транзакции.
2. Убедиться, что время, указанное в транзакции, больше, чем время сохраненное
   для этого валидатора в хранилище. Если нет, прекратить обработку транзакции.
3. Обновить время для этого валидатора в индексе `validators_time`.
4. Если количество меток в индексе, принадлежащих текущим валидаторам,
   составляет не менее `2f + 1`, где `f = (n - 1) / 3` – это максимальное
   количество византийских валидаторов, выполните следующие шаги. В противном
   случае прекратить обработку транзакции.
5. Отсортировать метки времени текущих валидаторов в порядке убывания (начиная
   с самого нового время).
6. Найти время с индексом `f + 1` в списке который получился.
7. Если полученное время `t` больше, чем предыдущее утвержденное время, замените
   утвержденное время на `t`.

Таким образом, утвержденное время может быть обновлено после каждой транзакции
с фактическим временем от любого узла-валидатора. Процедура учитывает возможные
изменения в списке валидаторов, обеспечивает монотонность индекса `time` и
допускает вредоносное поведение узлов-валидаторов.

## Доказательство корректности

Допустим что `T` обозначает список текущих временных меток валидаторов,
отсортированных в порядке убывания, как указано в шаге 5 вышеприведенного
алгоритма. Становится понятно, что в системе с количеством византийских узлов
не большим чем `f`,
любое время из `T` с индексом в интервале `[f + 1, 2f + 1]` является:

- Временем честного узла или
- Временем между отметками времени двух честных узлов. Поэтому такое время можно
  считать надежным.

Из практических соображений, всегда выбирается временная метка с индексом
`f + 1`,
так как это значение является надежным и в то же время самым новым.

[exonum-time]: https://github.com/exonum/exonum/tree/master/services/time
[tlsdate]: https://github.com/ioerror/tlsdate
[roughtime]: https://roughtime.googlesource.com/roughtime
